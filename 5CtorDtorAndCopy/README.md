## 构造、析构、拷贝语义

纯虚函数：
- 纯虚函数意味着该类成为抽象类，不能定义对象，派生类中必须重写。
- 纯虚函数可以有实现，不过只能在类外定义，类内需要使用`=0`声明。
- 纯虚函数可以被调用，不过只能被静态调用（比如在基类中调用），而不能通过多态机制调用。
- 如果将析构函数定义为纯虚，那么必须提供实现，因为派生类会调用基类析构（继承体系中每一个类对象的析构都会被调用），不定义的话链接会符号未定义。而一般来说并没有理由将析构定义为纯虚，除非有不得不将该类定义为抽象类的理由，并且找不到其他函数来定义为纯虚？
- 即是是抽象类也是需要提供构造函数的。
- 抽象类中是否应该包含成员是一个值得争论的问题，通常能够避免应该避免，但也存在需要将派生类公共数据提取到抽象类的场景，所以并没有标准答案。


虚拟规格（virtual specification）：
- 如果一个类在预期中不会被重写，那么不应该定义为虚函数。
- 决定一个虚函数是否需要定义为`const`是一件琐碎的事情，如果无法确定派生类中是否会更改类的成员，那么唯一能做的就是不要定义为const。

### C++的类型类别

POD(Plain Old Data)类型（简单旧数据）：
- 这是一种**类型类别**，并非具名要求。
- C++20中已弃用，改为使用其他类型类别，比如平凡类型（trivial type）。
- 以下四种类型都是POD类型：
    - 标量类型：算术类型、枚举类型、指针类型、成员指针类型、`std::nullptr_t`，这些类型的cv限定版本。
    - POD类。
    - 上述类型数组。
    - 这些类型的cv限定版本。
- 类型特性：`is_pod<T>::value`，C++20弃用。
- 表示与C兼容的数据类型。

平凡类型（trivial type）：
- 包括：
    - 标量类型。
    - 平凡类类型。
    - 上述类型数组。
    - 这些类型的cv限定版本。
- 类型特性：`is_trivial<T>::value`。

平凡可复制类：
- 至少有一个未被弃置的拷贝构造、移动构造、拷贝赋值或移动赋值运算符。
- 每个拷贝构造、移动构造、拷贝赋值运算符、移动赋值运算符都要么是平凡的（trivial），要么是弃置的。
- 有一个未被弃置的平凡析构函数。
- 类型特性：`is_trivially_copyable<T>::value`。

平凡的拷贝拷贝控制成员：
- 不是用户提供的，也就是说是隐式定义的。
- 类没有虚函数。
- 类没有虚基类。
- 为类的每个基类选择的对应成员都是平凡的。
- 类的每个类类型非静态成员的对应拷贝控制函数都是平凡的。
- 以上这些点也就是说，使用平凡拷贝构造拷贝一个类对象可以使用`std::memmove`来进行，使用平凡的构造函数构造一个对象就相当于什么也不做。

平凡类：
- 是可平凡复制类。
- 有一个或多个默认构造，全部是平凡或者弃置的，至少有一个未被弃置。
- 有一个或多个[合格的默认构造](https://zh.cppreference.com/w/cpp/language/default_constructor#.E5.90.88.E6.A0.BC.E7.9A.84.E9.BB.98.E8.AE.A4.E6.9E.84.E9.80.A0.E5.87.BD.E6.95.B0)，他们全部都是平凡的。
- 类型特性：`is_trivial<T>::value`。

标准布局类：
- 满足以下所有条件：
- 没有具有非标准布局类类型的、或者他们的引用的非静态成员。
- 没有虚基类和虚函数。
- 所有非静态数据成员具有相同访问限定。
- 没有非标准布局的基类。
- 该类和它的所有基类中的非静态数据成员和位域都在相同的类中首次声明。
- 额外的作为基类的特殊要求，见[标准布局类](https://zh.cppreference.com/w/cpp/language/classes#.E6.A0.87.E5.87.86.E5.B8.83.E5.B1.80.E7.B1.BB)。
- 类型特性：`is_standard_layout<T>::value`。
- 参考：[标准布局](https://zh.cppreference.com/w/cpp/language/data_members#.E6.A0.87.E5.87.86.E5.B8.83.E5.B1.80)、[标准布局类](https://zh.cppreference.com/w/cpp/language/classes#.E6.A0.87.E5.87.86.E5.B8.83.E5.B1.80.E7.B1.BB)

POD类：
- 是平凡类。
- 是标准布局类。
- 没有具有非POD类类型（或该类型数组）的非静态数据成员。
- 类型特性：`is_pod<T>::value`。

聚合体：
- 是下列类型之一：
    - 数组。
    - 符合以下条件的类类型（通常是struct或者union）。
        - 没有私有或保护的非静态数据成员。
        - 没有用户声明或继承的构造。
        - 没有虚基类、保护或私有基类。
        - 没有虚函数。
- 聚合体可以使用聚合初始化（在没有声明`initializer_list`参数的构造的情况下使用列表初始化）。
- C++20起可以用指派初始化器初始化聚合体：`T object { .des1 = arg1 , .des2 { arg2 } ... };`。
- 类型特性：`is_aggregate<T>::value`（C++17）。

### 无继承时的对象构造

不同生命周期的对象：
- 全局对象：在`main`之前被构造，在`exit`处调用析构。
- 局部对象：声明时构造，离开作用域析构。
- 动态对象：`new`时构造，`delete`时析构。

对于一个平凡类（或者说POD类）来说：
- 调用其（平凡）构造就和在C中表现一样，平凡的构造函数本质上不做任何事情。
- C++中所有对象都会得到初始化，全局函数则会在main函数被调用前初始化。
- C++中所有全局对象都会被以“初始化过的数据”来对待。
- 平凡的析构不会做任何事情。
- 平凡拷贝控制就是按位拷贝，相当于做`std::memmove`。
- 编译器通常都不会生成平凡的构造或者析构。

抽象数据类型（ADT）：
- 使用聚合初始化（对于聚合类）会比相同意义的构造函数的内联扩展更快一些。
- 仅对聚合类有效。

为继承做准备：
- 如果析构函数是平凡的，那么可以不将其声明为虚的。
- 虚函数会带来的东西：
    - 会给对象带来虚指针的内存消耗。
    - 也会给所有构造函数带来虚指针初始化的消耗。
    - 使合成的拷贝构造、拷贝赋值运算符不再平凡（但如果不显式定义，合成的析构仍然是平凡的）。
- 如果有NRVO，可以显式提供拷贝构造，即使合成的语义已经足够。

### 继承体系下对象构造

调用构造时发生了什么：
- 编译器会扩充每一个构造函数：
    - 成员初始化列表中的数据成员初始化操作会被放到构造函数体中，以成员声明的顺序。
    - 如果一个类类型的成员未在成员初始化列表中，那么它的默认构造会被调用。
    - 在构造函数体执行之前，如果类对象有虚指针，那么他们会被设置为指向恰当的虚表。
    - 在那之前，所有上一层的基类构造会被调用，以基类声明的顺序。
        - 如果基类在成员初始化列表中，那么其构造应被恰当地调用。
        - 如果没有在成员初始化列表中，那么调用其默认构造。
        - 如果基类是多重继承下的第二或者后继基类，this指针必须有所调整（传入基类构造的）。
    - 在那之前，所有虚基类构造必须被调用，从左到右，从最深到最浅。
- 编译器怎样合成：
    - 当调用了拷贝构造、拷贝赋值运算符时，对应的函数才会被合成出来。

虚继承：
- 虚继承中的虚基类将由每一个最末端的派生类负责初始化，而不能委托给其基类，其基类中的对于相关虚基类的代码将不会被执行。
- 所以在编译器进行构造函数扩充时，必须有条件地去执行虚基类的构造，当构造的是就是当前类型对象时才执行虚基类构造，如果是其派生类，那么虚基类构造将不被执行。
- 一种实现策略可以在扩充后给参数列表中除了`this`外再加一个`bool`变量表示是构造当前类型还是派生类型来做到。
    - 派生类构造中传入`true`表示是构造当前类型，然后构造基类时传入`false`以避免其中对于虚基类的构造。
- 另一中实现策略可以将构造函数一分为二，针对完整的对象和某对象中的基类子对象实现两份构造，其中对是否进行虚基类构造这个逻辑做了区分（虚基类虚指针设置亦同），这种方案可带来运行效率的提升。

虚指针初始化语义：
- 构造和析构中的调用：
    - 在构造函数中调用虚函数，将会是静态调用，而非动态调用。
    - 在析构函数中亦如此。
    - 那么构造和析构中调用了一个函数（无论虚还是非虚），而此函数中又调用了另一个虚函数呢？
        - 结果是被间接调用的虚函数会动态调用，但此时虚指针会指向当前类虚表，也就是和静态调用结果是一致的（见下面）。
    - 通常来说应避免在构造函数和析构函数中调用虚函数。
- 虚指针的初始化：
    - 时机：在（虚基类以及）基类构造函数初始化之后，在成员初始化列表之前。
    - 上述的基类构造和析构中虚函数的静态调用正是通过这个初始化顺序实现的。在基类构造中调用虚函数，虚指针还指向基类虚表，所以必然是调用得到基类的虚函数（无论自己定义重写还是继承来的）。
    - 这完美解决了上面提到的问题。
- 构造函数执行过程如下：
    - 派生类构造中，所有虚基类构造以及上一层的构造被调用。
    - 然后所有的虚指针被初始化，指向对应的虚表。
    - 有成员初始化列表的话，在构造中进行扩展，这其中的虚函数将会调用当前类的。
        - 这在语法上是安全的，在程序逻辑上是否安全取决于调用的虚函数是否使用了还未初始化的成员。
        - 但如果调用虚函数以其结果在成员初始化列表中初始化基类的话一定是不安全的，此时要么虚指针未设定好，要么指向错误的虚表。
    - 最后执行函数体中的代码。
- 仍存在的问题：
    - 如果构造派生类对象，且基类构造中未直接或者间接调用虚函数。那么基类中的虚指针设置操作是可以省略的。
    - 实际中尚未知是否有编译器会做这种优化，一种优化方法可以是上面提到的将基类构造一分为二。
- 析构函数：
    - 根据前面的分析，派生类析构函数体执行完后，执行基类析构之前，虚指针必定会被重新设置，这是毫无疑问的。后续详解。

### 对象复制语义

提供复制语义的选择：
- 什么都不做，实施默认行为。
- 提供显式的拷贝构造、拷贝赋值运算符。
- 拒绝复制：声明为private并且不提供定义，现代C++更好的做法是使用`=delete`。

何时需要提供自定义拷贝控制成员：
- 默认行为的语义不安全或者不正确时。
- 只有非平凡（non-trivial）的拷贝控制成员才会被合成出来，否则就执行按位拷贝语义。

定义拷贝赋值运算符：
- 派生类中时需要手动去调用基类的拷贝赋值运算符，以`Base::operator=(rhs)`的形式，有多个基类就需要调用多次，每个虚基类也需要独立调用一次。
- 同构造函数一个道理，虚基类的拷贝也应该在最末端的类中做，在调用基类子对象的拷贝赋值运算符时也应该抑制虚基类的赋值。
    - 因为拷贝赋值运算符也是一个普通成员函数，所以为其添加一个参数的做法行不通了。
    - 那么可行的方案就只有分化拷贝赋值运算符，为独立对象和基类子对象实现两个逻辑了。
- 但因为程序员需要手动去调用基类拷贝赋值运算符，那么编译器为什么会据此分化呢？
    - 事实上，编译器对拷贝赋值运算符在虚继承情况下的行为不佳。
    - 以本地环境（GCC8.1.0）为例，编译器并不会抑制基类基类子对象中对虚基类的拷贝复制操作。
    - 标准也并没有规定编译器合成的拷贝赋值运算符不能对虚基类赋值一次以上。
    - 如果需要程序员来手动分化的话，通常而言很难实现。
- 虚基类是C++中非常复杂的一个语法，通常认为上述这点是C++的一个弱点。
- 当使用虚基类时，应该非常地谨慎。如果虚基类的复制操作是非平凡的、执行多次可能会有副作用的，那么通常不推荐这样写（可以拒绝赋值操作、修改设计仅在最末端派生类中对虚基类赋值、或者修改虚基类）。
- 结论：
    - 为了保证虚基类一定得到了赋值，需要在最末端的派生类的赋值运算符中手动调用虚基类赋值运算符（就像构造那样）。
    - 但这并不会保证虚基类的赋值操作只被调用一次（并非在类似于构造函数成员初始化列表那样的东西中做，而是在函数体中做的），这有可能会导致虚基类子对象的多次拷贝（C++标准并不规定拷贝赋值运算符要抑制基类中的虚基类赋值）。
    - 作者甚至提供一个建议：不要在虚基类中声明数据（这样将没有也不需要一个合成的拷贝赋值操作）。

### 对象性能

通常而言拷贝和赋值的性能遵从一般的规律（从快到慢）：
- 单一继承。
- 多重继承。
- 虚继承。


### 析构语义

什么时候编译器会合成析构函数：
- 在非静态成员对象或者基类中定义有析构时，编译器才会自动合成一个析构函数出来。
- 否则析构函数会被认为不需要，也就不需要被合成出来，当然也就不需要被调用。

一个程序员定义的析构同样会被扩展：
- 扩展的方式非常像构造中扩展的方式，不过顺序相反。
- 派生类的析构执行过程中，函数体逻辑执行完后，会按照构造的逆序析构其所有成员对象，这个逻辑被扩充到派生类析构中。
- 虚指针重设：如果一个对象内含虚指针，那么当派生类的析构执行完后，会开始执行基类析构，在这之前，会重设虚指针会基类虚指针。
- 如果任何上一层的基类有析构，那么他们会以声明相反顺序在派生类析构执行完后调用（如果基类有虚函数，那么在这之前会有虚指针重设的过程）。
- 如果虚基类拥有析构，那么会按照构造顺序逆序调用。

虚基类处理：
- 对于虚基类的析构的处理，最佳的实现策略依然是一分为二维护两份代码：
    - 完整对象的析构：直接执行。
    - 基类子对象的析构：不会调用虚基类的析构（会有最末端派生类在最后去调用）。
