## 运行时语义

本章主要关注一些运行时的代码转换，比如期间生成的临时对象、代码如何被编译器扩展等。

### 对象的构造和析构

构造：
- 对象的构造被安插在其定义处，这毫无疑问。

析构：
- 对象离开作用域就需要被析构，这会包含很多种情况：
- 在其定义之后的返回语句，为了避免这种情况导致的大量析构，建议用到时再定义。
- `break continue`这种会导致局部作用域变量离开作用域的语句。
- 还有C语义的遗产`goto`语句也是这样。

全局对象：
- C++保证，全局对象保证在`main`中用到该全局变量之前构造，在`main`函数结束之前将全局变量析构。
- C++中所有全局对象防止在data段。如果显式指定初值，那么将以该值为初值，否则其内存内容将为0。
- 构造操作会在执行的时候才被执行。
- 构造和析构操作将被安插到程序的执行前和结束时。
- 书中提供了一个实现手段：
    - 将每个全局对象的初始化和析构封装为一个独特的函数，其中含有必要的构造/析构调用或者内联扩展。
    - 在生成的`main`函数最前面安插一个`_main`，依次调用这些函数。
    - 在`main`函数结束时安插`exit`，其中依次每个全局对象的调用析构。
- 引入的新问题：
    - 这些代码不能位于`try`块内，如果抛异常将直接`terminate`。
    - 跨模块做静态初始化的依赖顺序。

局部静态对象：
- 局部静态对象只被构造一次，析构一次。
- 一个不可行的策略：
    - 无条件在程序起始时构造。
    - 但这会导致未被调用的函数中的局部静态对象也被初始化了，尽管他们还没有被用到或者永远也不会被用到。
    - 所以在函数被调用时才去初始化是更好的选择，而C++标准也已经强制要求了这一点，所以这种策略就行不通了。
- 一个可行策略：
    - 隐式且唯一对应地引入一个`bool`变量表示某个局部静态变量是否已经被构造。
    - 初值为`false`，第一次执行时构造，置位`true`，然后根据这个变量判断则不再执行构造。

对象数组：
- 对象数组会被按照次序依次初始化，并且按照逆序析构。
- 编译器实现时：
    - 如果数组没有任何初始值，所有对象初始化，可以将构造操作委托给一个库函数`vec_new`。依次默认构造所有元素。
    - 同理析构委托给`vec_delete`。
    - 如果定义数组时进行了列表初始化，那么可以将进行了初始化的部分直接转化为构造函数的调用，剩余部分使用`vec_new`。


### new和delete运算符

new运算符：
- 有两个步骤构成：分配内存，初始化（如果有初始化或者构造函数）。
- 初始化操作在内存分配成功之后才会执行，两个步骤均可能抛出异常。
- 如果是在内存分配中抛出异常，那么初始化不会执行，直接将异常向上抛出（通常是`bad_alloc`）。
- 如果在构造中抛出异常，那么会将已成功分配的内存释放掉，然后再将异常向上抛出。

delete同理分为两个步骤：
- 析构（如果有的话），释放内存。

array new：
- 当动态分配一个数组`auto p = new Type[Size]`时。
- 首先分配内存，如果有必要会进行初始化，比如给了初始值或者类型有构造函数。
- 有构造函数的话就会调用上面提到的`vec_new`。
- 针对动态数组的释放操作`delete []`，需要去查找大小，相比单纯的`delete`需要不少额外操作，所有需要作区分以便能够`delete`高效执行。
- 及其古早版本的C++中，需要程序员显式执行`delete[]`的元素大小。
- 使用基类指针指向排生类数组不是一个好主意，因为取后续元素会按照基类大小来做偏移，这只在派生类大小和基类一样时能够工作，所以请不要这么做。

placement new：
- 使用方法：`new (location) Type`。
- 这个`new`运算符调用一个特殊形式的`operator new`。
- 通常placement new只做一个事情，在特定内存位置构造/初始化某对象。
- 注意是直接在内存处构造，如果原先已经有一个对象，原先对象的析构是不会被调用的。
- 并没有与此对应的placement delete，我们可以直接使用对象的析构函数销毁对象。
- 在使用placement new时，通常来说应避免构造派生类对象并将其赋给基类指针，原因：
    - 空间有可能不足。
    - 析构时将只能调用基类析构，就算析构是虚的，但编译器可能会直接静态基类析构（本地环境中Gcc8.1.0会执行虚调用正确析构）。
    - 在空间足够且确定编译器会执行虚析构时，则可以使用。

### 临时对象

临时对象：
- 现行的标准下，搞清楚[复制消除](https://zh.cppreference.com/w/cpp/language/copy_elision)，剩余的问题只要能搞懂代码的语义都基本不需要额外费心。
- 临时对象的销毁，应该是对完整表达式（最外围的那个表达式）求值过程中最后一个步骤。
- 持有表达式执行结果的临时变量，应该存留到对象的初始化操作完成为止。
- 如果临时变量绑定到左值/右值引用，临时变量的声明周期将被延长到引用的声明周期结束。

总结：
- 临时对象是不可避免的，复制消除可以一定程度上减少消耗。
- 为了减少临时变量和对象拷贝，可以使用的手段：
    - 对于复制代价较大的对象，引用传递取代值传递。
- 相信编译器优化，当出现性能瓶颈时再来考虑这些问题是比较好的选择。
- 当然如果你在实现一个计算密集且性能敏感的库，那么这是值得谨慎考虑的问题。