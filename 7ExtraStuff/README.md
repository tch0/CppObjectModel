## 对象模型中的剩余事物

这节讨论讨论模板、异常处理和RTTI。

### 模板

模板带来的东西：
- 泛化。
- 运行时性能提升。
- 编译时间提高。
- 程序膨胀。
- 复杂而难以调试的报错。

模板的讨论方向：
- 模板声明。
- 如何实例化类对象、内联非成员模板函数、成员模板函数：这些东西每个编译单元都会生成一份。
- 如何实例化非成员模板函数、成员模板函数、静态模板类成员：这些都是每个可执行文件中只需要一份的东西。

模板的实例化：
- 类模板中的静态成员、枚举都必须等到类模板实例化之后才能使用。
- 定义模板类指针，并不会导致类模板的实例化，因为指针本身并不是一个对象，声明一个指针并不需要知道类的内存布局、大小等信息。
- 如果是模板类引用，则会进行实例化。因为引用必须被绑定到一个对象上，所以是必然存在对象的。
- 成员函数需要被使用到时才会实例化。这样做的原因是：提高编译效率，使得部分使用一个类模板成为可能。

模板的错误报告：
- 在类模板声明中，所有与模板类型参数相关的检验都必须延迟到真正的实例化操作发生时才能检验出来。
- 编译器解析模板定义时，只能检验出少量的错误。
- 模板实例化是否发生错误与具体的模板参数相关。

模板中的名称决议：
- 这其中需要区分两种意义：
    - 模板声明作用域。
    - 模板实例化作用域。
- 模板之中，对于一个非成员名称的决议结果，是根据这个名称使用是否与“用以实例化该模板的类型参数”有关而决定的。
    - 如果无关：那么以模板声明的作用域来决定名称。
    - 如果相关：以模板实例化的作用域来决定名称。
- 模板声明作用域：专注于一般的模板类。
- 模板实例化作用域：专注于特定的实例。
- 编译器决议算法需要决定哪一个才是适当的作用域，从而在其中搜寻适当的名称。

成员函数的实例化行为：
- 类模板中的成员函数只会生成被用到的那一部分，没有用到的部分则不会生成。
- 一般而言用两种手段实现这种行为：
    - 编译期策略：程序代码必须在每个编译单元中编译生成一份，链接时可用。
    - 链接时策略：编译时不生成，而在链接时有一些元编译工具引导编译器的实例化行为。
- 编译器会在每个编译单元中进行实例化，然后由链接器提供支持，只保留下其中一个实例，其余全部忽略。
- 这样就会导致每个编译单元都需要实例化，显著提升了编译时间。
- 当然现在也提供了类模板显式实例化，就可以只实例化一次，但是所有成员函数都会被实例化。
- 模板函数也是可以被显式实例化的。
- 如果程序十分巨大，编译时间十分地长，那么在某个模块中预先显式实例化所有用到的类模板、函数模板是能够有效减低编译时间的，虽然这会显得非常枯燥。

### 异常处理

异常处理：
- 编译器为了支持异常机制需要做的事情：
    - 根据`catch`子句处理抛出的异常，这需要追踪堆栈中的每一个函数的目前作用区域。
    - 异常的捕获要求某种运行时类型识别机制。
    - 最后还需要某种机制用来管理被抛出的异常对象，包括构造、存储、可能的析构、内存清理以及一般存取。
- 一般而言，异常处理机制需要与编译器产生的数据结构以及运行时的一个异常库的紧密合作。
- 在程序大小和执行速度之间，编译器需要作出取舍。
    - 为了维护执行速度，编译器可以在编译期建立用于支持异常的数据结构，这会造成程序的大小膨胀。
    - 为了维护程序大小，编译器可以选择在运行时建立这些数据结构，这意味着额外的运行时代价。

速览异常处理：
- 三个语法组件：`try catch throw`。
- 当一个异常被抛出时：
    - 程序控制权从函数调用中释放，转而寻找最近的`catch`，如果异常未在当前函数中捕获，那么就会一级一级向上传递。
    - 每一级向上传递的过程都会导致当前函数调用的堆栈被弹出（即栈展开过程，stack unwinding）。
    - 每一个函数的堆栈被弹出都需要将所有已经构造的局部变量析构（需要相关的机制）。
- 为了支持异常处理，就需要记录已经构造的临时对象，两种实现方式：
    - 将异常抛出前已构造的局部对象和抛出后才会构造（异常抛出时尚未构造）的两个区域用一个表示即将被销毁的局部对象的链表链接起来。
    - 另一种做法是两个区域共享一个链表，运行时扩大或者缩小。
- 异常处理同时导致了资源管理的语义，资源获取之后可能未曾释放就抛出异常，导致资源泄漏。
    - 比较粗浅的方式是使用`catch(...)`之后做必要的资源释放，然后再向上抛出。太多这种代码后，会导致代码冗长，`try catch`泛滥。
    - 最佳实践是使用RAII：利用异常处理的栈展开，自动析构RAII对象时释放相关资源。

支持异常处理：
- 当异常发生时，编译系统系统做的事情：
    - 检验发生throw的函数。
    - 决定throw是否发生在`try`块中。
    - 若是，则编译系统把异常类型和每一个`catch`子句中用于接收的异常类型进行比较。
    - 如果吻合，则将控制权交到`catch`子句。
    - 如果`throw`不发生在`try`块中，或者没有一个`catch`子句吻合，那么系统必须摧毁所有已经构造的局部对象、进行栈展开将当前函数的堆栈弹出、进入上一层（也就是程序堆栈的下一个）函数调用中，重复执行上述步骤。
- 决定throw是否发生在`try`块中：
    - 一个函数可以被分为三个部分：`try`区域外且没有活跃的局部对象、try区域外有活跃对象、try区域内。
    - 函数被编译后，每个部分都会有一个指令的开始和结束，通常可以通过一个表来记录。
    - 通过查阅抛出异常时指令位于那一部分即可确定throw是否发生在`try`块中。
- 比较抛出异常类型和每一个catch子句的异常类型：
    - 对于每个被抛出的异常，编译器需要对异常类型进行编译，将（公有或非公有【确保成员函数中也能正确捕获】）基类的信息编码到异常类型中。
    - RTTI正是为了支持异常处理而获得的副产品。
    - 编译器还需要为每一个catch子句产生一个类型描述器。
    - 每个函数还应该产生一个异常表格，描述与函数相关的区域、必要的善后代码以及catch子句的位置。
- 当一个异常对象被程序抛出时，会发生什么：
    - 抛出的异常对象会被存储在一个异常堆栈中。
    - 从throw端传递到catch子句的是异常对象的地址、类型描述器以及可能会有的异常对象描述器。
    - 当使用值捕获异常时，将以该异常对象作为参数拷贝构造一个新的异常。
    - 当使用引用捕获异常时，将会引用位于异常栈中的当前异常。
    - 在任何情况下，直接使用`throw`都是直接抛出原异常，也就是上一层抛出时位于异常栈的那一个，而不是任何新创建的异常。
    - 也正因为此，引用捕获到异常时任何对异常对象的修改（具有多态效应，虚函数会动态调用），都将会反映到下一次捕获的对象上。
    - 只有当`catch`捕获到异常并且执行完后不再重新抛出异常，被传递的那个异常才会被销毁。
    - 可以使用`exception_ptr`保存异常栈的异常，保存后可避免异常对象被销毁（大概率是通过引用计数实现），从而将其传递到其他地方。
- 异常处理的额外开销：
    - C++语言设计的一个核心指导思想是零开销抽象，即追求在不对已有特性造成任何额外开销的情况下引入新特性。
    - 但异常处理就是零开销抽象的一个典型反例，异常处理并非零开销的。
    - 最终的二进制程序中必须为异常处理付出额外空间、额外运行时间的代价。
    - 在性能敏感、计算密集的程序中（甚至所有C++程序），很多C++程序员会推崇禁用C++异常处理（指在代码中尽量不使用异常处理，全部使用返回值做判断，而非直接将异常处理机制从语言中剔除，普通程序员不具备这个能力），编译器通常会提供一些有限的支持。

异常处理相关类型与函数：
- 类型`exception_ptr`保存被抛出位于异常栈中的异常。
- `std::exception_ptr current_exception() noexcept;`获取当前异常。
- `template< class E > std::exception_ptr make_exception_ptr( E e ) noexcept;`从异常对象创建一个`exception_ptr`。
- `[[noreturn]] void rethrow_exception( std::exception_ptr p );`重新抛出异常。
- [More](https://zh.cppreference.com/w/cpp/error)

### RTTI

类型安全的向下转换：
- C++的RTTI机制提供了安全的向下转换（基类转派生类）机制，仅对那些多态类型有效。
- 这种类型安全的向下转换的实现对于非多态类型并无任何额外负担。
    - 类型信息（`type_info`）被放到虚表中（通常是第一个slot），由编译器静态设定。
- `dynamic_cast`运算符就是这个类型安全的向下转换。
    - 如果向下转换不安全，会得到空指针。
    - 如果安全，会得到派生类指针。

引用并非指针：
- 引用不能为空，但`dynamic_cast`可以用于引用。
- 向下转换安全时，能够得到派生类引用。
- 不安全时，会抛出`bas_cast`异常。
- 通常来说转换为引用应当先对对象的`typeid`进行判断，确定一定能够成功才进行转换，而不是通过是否抛出异常来判断。

typeid运算符：
- 返回一个`type_info`的const引用。
- `type_info`能够使用`==`进行判断。
- `type_info`提供的RTTI是支持异常的必要特性。
- 通常的策略是在运行时需要才生成`type_info`对象，而非程序一开始就产生所有类型的`type_info`对象。
