## 函数语义

### 成员函数的各种调用方式

C++的设计准则之一就是：非静态成员函数必须和非成员函数具有同样的效率。
- 所以选择成员函数并不会造成额外负担。
- 成员函数会被经过以下步骤内化为非成员函数的形式：
    - 改写函数签名，在参数列表前添加一个该类型的指针参数（如果是const成员函数则具有底层const修饰）。
    - 对于每一个非静态数据成员的存取操作该有this指针来存取。
    - 将成员函数重写为一个外部函数。经过名称重整（name-mangling）处理后，在生成的二进制中具有唯一的符号。
    - 比如成员函数`void Foo::bar(int x)`在本地环境（GCC8.1.0）经过名称重整后在二进制中的符号是`_ZN3Foo3barEi`，于是`foo.bar(1)`调用在二进制中被编译器编译为等价的`_ZN3Foo3barEi(&foo, 1)`（二进制形式）调用（NRVO也通过加一个引用参数这种方式的代码转换得到实行）。

名称重整（name-mangling）：
- 在编译到汇编时，函数和变量名称会经过名称重整，其命名空间、类名（对于类成员）、函数签名（对于函数，因为允许函数重载，所以必须要对函数签名做区分）都会被重整为名称的一部分。
- 也就是说每一个函数、变量都会具有独一无二的名称。并且这种重整各个编译器的实现往往不一致，也就导致了不同编译器编译出的二进制ABI不兼容（名称重整规则是ABI的一部分），这也是C++代码二进制复用困难的原因之一。
- 但在C中就不是这样，C中的函数不允许重载、也没有命名空间、没有类作用域。二进制的名称是完全能够统一的。所以实践中很多时候C++中代码都会为了ABI兼容性而封装一层C接口导出供用户使用。手段就是使用`extern "C"`，此时编译出的二进制的相应名称是C风格的，将没有名称重整。
- 因为名称重整的存在，在链接时就可能看到各种重整过的名称，不要感到惊讶，去了解一下你所用的编译器的名称重整规则和相关的demangling工具，就能得到原始名称。

虚成员函数：
- 虚指针是一个指针（和普通指针一个大小），指向类的一个虚表，一个类的所有虚函数（包括继承而来的或从自己开始定义的）将会被放进虚表中。
- 所有对虚函数的调用都将会转化为对某个虚表项（每个项是一个函数指针）的调用。也就是在运行时有一层间接层次消耗。
- 例如：`ptr->normalize()`，如果对应虚表项下标是1，那么将会在运行时被转化为`(*ptr->vptr[1])(ptr)`，this将作为隐式参数传递进去。但是在代码中是不能显式这样写的。
- 而在通过对象而非指针和引用调用的场景中，或者在成员函数内部通过类作用域调用的虚函数来说，调用哪个虚函数是能够被确定下来的，这时是不需要通过虚表去间接调用的。
- 通过指针或者引用多态调用一个虚函数时，因为虚函数可以被重写，所以在运行时才能确定要调用哪一个虚函数，而虚函数表项的下标是编译期根据基类虚函数表确定的，所以说派生类的对应虚函数表项下标一定是与基类一致的（这由编译器来保证）。

静态成员函数：
- 通过类名和作用域运算符来调用，也可以通过对象或者对象指针来调用。
- 无论何种调用，都会被解析为直接对静态成员的调用。
- 如果通过结果为某一类对象的表达式来调用该类的静态函数，虽然原则上不需要求值也能调用，但为了保留表达式造成的可能的副作用，表达式会被求值。
- 静态成员函数的名称也会经过重整，因为其也是定义在类作用域内的。
- 对静态成员函数取地址得到的普通函数类型的指针，而非成员函数指针。
- 静态成员函数没有this指针参数，因此完全可以像普通函数一样使用，比如赋给函数指针变量，绑定到`std::function`，成为回调函数等。

### 虚成员函数

虚函数：
- 通过指针或者引用调用才具有多态。
- 指针或者引用指向的对象的真实类型，决定了该选择哪一个虚函数。
- 知道虚函数的位置，我们才能够调用它。
- 所以虚函数的信息毫无疑问就应该在派生类和基类中以相同的顺序被保存到了每一个对象中，但是虚函数没有必要被保存到每一个对象，因为对于每个对象，这些信息都是一致的。所以有了虚表，在对象中则用虚指针来指向虚表。
- 虚函数表中的虚函数可能是在派生类中重写的，也可能是继承自基类的。 

虚表：
- 虚函数表是编译期确定的，每个类（如果有虚表的话）唯一。
- 在该类对象构造时，需要将该类的虚表的地址赋给构造的对象的虚指针。
- 每一个虚函数被指派到一个固定的索引值，这个索引值在整个继承体系中保持和特定的虚函数的对应关系。
- 一个`pure_function_called()`特殊实例可以被放在虚函数的表项中来扮演占位或者运行时异常处理函数的用途。
- 为了实现RTTI，一个`type_info`对象也被放在虚表中。使用`typeid`运算符时就会去通过虚表去找到该对象。
- 覆写的虚函数会被放到对应虚表slot中，没有覆写的虚函数则会将基类虚函数地址拷贝到对应虚表slot中，添加了新的虚函数则被放入虚表末尾形成新的slot。

**多重继承中的虚函数**：
- 在多重继承中支持虚函数的复杂度，主要在于第二个及其后继基类身上，以及必须在**运行时调整this指针**这一点。
- 当将派生类指针或者引用给到第二个或后继基类上时，相当于做了指针的转换，根据前面的讨论，这时地址会发生变化。通过该指针去调用其基类虚函数时，会在派生类对象中第二个基类子对象中的虚表去查找执行虚调用。
- 当要通过第二个基类子对象（指针）删除该对象时，也是去第二个虚表中查找该基类子对象的虚析构函数（此时是指向派生类析构的）执行。也就是说虚析构函数会出现在每一个虚表中。
- this指针指向哪儿：
    - 一定记住的是，在派生类的函数中（无论虚函数还是非虚函数），this指针永远都是代表派生类整体对象的首地址，而非任一个基类子对象。此时取派生类成员以及基类子对象成员都是根据派生类首地址的偏移来确定的。
    - 而如果调用的是继承的来自于基类的虚函数的话，指针偏移毫无疑问就是根据基类子对象的首地址来确定的。
- 所以this指针的调整会发生在以下情况中：
    - this需要指向派生类对象，却指向了基类子对象：
        - 使用基类指针指向派生类对象时，会将地址调整到其基类子对象位置（非自然多态中调整后指针中的地址就会变）。此时调用派生类的虚函数时，this指针就需要被调整回派生类对象的首地址。
        - 使用`delete`运算符删除基类指针指向的派生类对象时，也需要将地址调整回派生类对象的起始处（对象首地址决定了最终内存的释放）。
    - this需要指向基类子对象，却指向了派生类对象：
        - 使用派生类对象调用继承自基类的虚函数时，也需要将地址从派生类地址调整到基类子对象地址。
- 如何做到指针的调整：
    - 通常做法是在这种需要调整的情况下，虚表不直接指向一个虚函数指针，而是指向一个thunk（据说命名来源于Donald E.Knuth的Knuth倒过来），thunk中会生成调整this指针的代码，然后才是使用调整后的this调用虚函数。
    - 等效的伪代码看起来就像是这个样子，`doSomething_thunk`的地址被放到虚函数表项中：
    ```C++
    doSomething_thunk:
        this += offset;
        doSomething(this);
    ```
    - thunk技术允许虚表项中继续保存一个指针，而不需要额外保存一个偏移。于是对于那些不需要调整的虚函数（自然多态，大部分情况都是这样的），就没有任何额外负担了。
    - 所以即使调用同一个虚函数，经由派生类、第一个基类调用和经由第二个及以后的基类调用，在多重继承中的多个虚表中对应的thunk（自然多态则直接就是虚函数地址）都是不一样的，偏移是不一样的，但最终的效果都是使用相同的this调用同一个虚函数。
    - this指针调整是在访问虚表之后的，访问虚表则是根据调整前的基类子对象地址来的。
- 最后总结：
    - 多重继承中n个基类会产生n个虚表，第一个基类和派生类共用第一个虚指针与虚表：
        - 第一个基类只使用第一个虚表中前面的来自第一个基类的虚函数，而派生类会在其中加入继承自其他基类的和在派生类中新加入的虚函数。
        - 通过第一个基类指针引用或者派生类指针引用调用派生类引入的、重写的、或者继承自第一个基类的虚函数时直接使用this指针从虚表中找到并调用虚函数。
        - 通过派生类指针调用继承自第二个和后继基类的虚函数时（即未覆写的），需要经过thunk中的this指针调整将this调整到基类子对象地址，然后调用虚函数。
    - 第二个基类即后续的基类各拥有一个虚指针与虚表：
        - 当经由第二个基类指针引用来调用虚函数时，虚指针经由基类子对象来寻址（虚指针通常放对象开头），在调用派生类重写的虚函数时需要经过thunk中的this指针调整后，将this从基类子对象调整到派生类对象首地址，再调用虚函数。
    - 还有一种调整发生在派生类重写的虚函数返回基类虚函数返回值基础类型的派生类的指针引用的情况，如果这里的基类是多重继承的第二即后继基类，那么：
        - 此时如果用基类指针调用派生类虚函数，得到返回值后必须赋给基类指针或者引用，就需要进行一个指针转换，从派生类首地址转换为基类子对象地址。

一个生僻语法：
- 在C++的虚函数中，某些情况下派生类中重写的虚函数的返回值可以和基类不同。
    - 如果基类虚指针是基础类型，那么派生类的返回类型必须和父类严格一致，否则报错。
    - 如果基类虚函数返回某个基类指针或者引用，那么派生类虚函数的返回类型可以和基类返回类型相同，也可以是基类返回类型的派生类（不能是基类）的指针或引用。
- 这个规定让这种写法成为可能：
```C++
class Base1
{
public:
    virtual ~Base1() {}
    virtual Base1* clone()
    {
        return new Base1();
    }
};

class Base2
{
public:
    virtual ~Base2() {}
    virtual Base2* clone()
    {
        return new Base2();
    }
};

class Derived : public Base1, public Base2
{
public:
    virtual Derived* clone() override
    {
        return new Derived();
    }
};
```
- 派生类中同一个虚函数同时重写了两个基类的两个虚函数。也就是`Derived::clone()`函数的地址将同时位于派生类`Derived`的两个虚表中。
- 这个语法的核心逻辑就是里氏替换原则，也就是基类中返回基类的指针或者引用，因为派生类返回值是可以赋给基类指针和引用的。
- 但因为C++的模板是非协变（invariant）的，所以这里只能使用指针和引用这种语言语法层次的支持，而不能使用智能指针这种库定义或者自定义的东西。
- TODO：但在最新的C++20中，使用concept不知道能否做到自行实现的模板协变和逆变，待探究。

虚继承下的虚函数：
- 虚表中保存着虚基类相对对象首地址的偏移。
- 由于虚基类会被提取出来单独放在对象末尾，所以虚基类和其派生类天然就是非自然多态，自然会面临所有this指针调整的问题。再加上通过派生类地址获取虚基类子对象地址本身就要通过一层虚表查找的间接。
- 道理和上面是相同的，不再赘述。
- 就实践中而言，虚基类并非那么常见的角色，通常应该避免使用带有非静态成员的虚基类。