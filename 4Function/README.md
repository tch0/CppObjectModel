## 函数语义

### 成员函数的各种调用方式

C++的设计准则之一就是：非静态成员函数必须和非成员函数具有同样的效率。
- 所以选择成员函数并不会造成额外负担。
- 成员函数会被经过以下步骤内化为非成员函数的形式：
    - 改写函数签名，在参数列表前添加一个该类型的指针参数（如果是const成员函数则具有底层const修饰）。
    - 对于每一个非静态数据成员的存取操作改由this指针来存取。
    - 将成员函数重写为一个外部函数。经过名称重整（name-mangling）处理后，在生成的二进制中具有唯一的符号。
    - 比如成员函数`void Foo::bar(int x)`在本地环境（GCC8.1.0）经过名称重整后在二进制中的符号是`_ZN3Foo3barEi`，于是`foo.bar(1)`调用在二进制中被编译器编译为等价的`_ZN3Foo3barEi(&foo, 1)`（二进制形式）调用（NRVO也可以通过加一个引用参数这种方式的代码转换得到实行）。

名称重整（name-mangling）：
- 在编译到汇编时，函数和变量名称会经过名称重整，其命名空间、类名（对于类成员）、函数签名（对于函数，因为允许函数重载，所以必须要对函数签名做区分）都会被重整为名称的一部分。
- 也就是说每一个函数、变量都会具有独一无二的名称。并且这种重整各个编译器的实现往往不一致，也就导致了不同编译器编译出的二进制ABI不兼容（名称重整规则是ABI的一部分）。【各种编译器甚至同一编译器多个不同版本ABI不兼容是C++代码二进制复用困难的主要原因。】
- 但在C中就不是这样，C中的函数不允许重载、也没有命名空间、没有类作用域。ABI接口相对来说是比较统一的。所以实践中很多时候C++中代码都会为了ABI兼容性而封装一层C接口导出供用户使用。手段就是使用`extern "C"`，此时编译出的二进制的相应名称是C风格的，将没有名称重整。
- 因为名称重整的存在，在链接时就可能看到各种重整过的名称，不要感到惊讶，去了解一下你所用的编译器的名称重整规则和相关的demangling工具，就能得到原始名称。

虚成员函数：
- 虚指针是一个指针（和普通指针一个大小），指向类的一个虚表，一个类的所有虚函数（包括继承而来的或从自己开始定义的）将会被放进虚表中。
- 所有对虚函数的调用都将会转化为对某个虚表项（每个项是一个函数指针）的调用。也就是在运行时有一层间接层次消耗。
- 例如：`ptr->normalize()`，如果对应虚表项下标是1，那么将会在运行时被转化为`(*ptr->vptr[1])(ptr)`，this将作为隐式参数传递进去。但是在代码中是不能显式这样写的。
- 而在通过对象而非指针和引用调用的场景中，或者在成员函数内部通过类作用域调用的虚函数来说，调用哪个虚函数是能够被确定下来的，这时是不需要通过虚表去间接调用的。
- 通过指针或者引用多态调用一个虚函数时，因为虚函数可以被重写，所以在运行时才能确定要调用哪一个虚函数，而虚函数表项的下标是编译期根据基类虚函数表确定的，所以说派生类的对应虚函数表项下标一定是与基类一致的（这由编译器来保证）。

静态成员函数：
- 通过类名和作用域运算符来调用，也可以通过对象或者对象指针来调用。
- 无论何种调用，都会被解析为直接对静态成员的调用。
- 如果通过结果为某一类对象的表达式来调用该类的静态函数，虽然原则上不需要求值也能调用，但为了保留表达式造成的可能的副作用，表达式会被求值。
- 静态成员函数的名称也会经过重整，因为其也是定义在类作用域内的。
- 对静态成员函数取地址得到的是普通函数类型的指针，而非成员函数指针。
- 静态成员函数没有this指针参数，因此完全可以像普通函数一样使用，比如赋给函数指针变量，绑定到`std::function`，成为回调函数等。

### 虚成员函数

虚函数：
- 通过指针或者引用调用才具有多态。
- 指针或者引用指向的对象的真实类型，而对象的真实类型（通过虚指针和虚表）决定了该选择哪一个虚函数。
- 知道虚函数的位置，我们才能够调用它。
- 所以虚函数的信息毫无疑问就应该在派生类和基类中以相同的顺序被保存到了每一个对象中，但是虚函数没有必要被保存到每一个对象，因为对于每个对象，这些信息都是一致的。所以有了整个类共用的虚表，在对象中则用虚指针来指向虚表。
- 虚函数表中的虚函数可能是在派生类中重写的，也可能是继承自基类的。 

虚表：
- 虚函数表是编译期确定的，每个类（如果有虚表的话）唯一。
- 在该类对象构造时，需要将该类的虚表的地址赋给构造的对象的虚指针。
- 每一个虚函数被指派到一个固定的索引值，这个索引值在每一条继承链中保持和特定的虚函数的对应关系。
- 一个`pure_function_called()`特殊实例可以被放在虚函数的表项中来扮演占位或者运行时异常处理函数的用途。【但通常未实现的纯虚函数是不会代码中被调用的，那通常会导致编译器报错。】
- 为了实现RTTI，一个`type_info`对象也被放在虚表中。使用`typeid`运算符时就会去通过虚表去找到该对象。
- 覆写的虚函数会被放到对应虚表slot中，没有覆写的虚函数则会将基类虚函数地址拷贝到对应虚表slot中，添加了新的虚函数则被放入虚表末尾形成新的slot。

**多重继承中的虚函数**：
- 在多重继承中支持虚函数的复杂度，主要在于第二个及其后继基类身上，以及必须在**运行时调整this指针**这一点。
- 当将派生类指针或者引用给到第二个或后继基类上时，相当于做了指针的转换，根据前面的讨论，这时地址会发生变化。通过该指针去调用其基类虚函数时，会在派生类对象中第二个基类子对象中的虚表去查找执行虚调用。
- 当要通过第二个基类子对象（指针）删除该对象时，也是去第二个虚表中查找该基类子对象的虚析构函数（此时是指向派生类析构的）执行。也就是说虚析构函数会出现在每一个虚表中。
- this指针指向哪儿：
    - 一定记住的是，在派生类的函数中（无论虚函数还是非虚函数），this指针永远都是代表派生类整体对象的首地址，而非任一个基类子对象。此时取派生类成员以及基类子对象成员都是根据派生类首地址的偏移来确定的。
    - 而如果调用的是继承的来自于基类的虚函数的话，指针偏移毫无疑问就是根据基类子对象的首地址来确定的。
- 所以this指针的调整会发生在以下情况中：
    - this需要指向派生类对象，却指向了基类子对象：
        - 使用基类指针指向派生类对象时，会将地址调整到其基类子对象位置（非自然多态中调整后指针中的地址就会变）。此时调用派生类的虚函数时，this指针就需要被调整回派生类对象的首地址。
        - 使用`delete`运算符删除基类指针指向的派生类对象时，也需要将地址调整回派生类对象的起始处（对象首地址决定了最终内存的释放）。
    - this需要指向基类子对象，却指向了派生类对象：
        - 使用派生类对象调用继承自基类的虚函数时，也需要将地址从派生类地址调整到基类子对象地址。
- 如何做到指针的调整：
    - 通常做法是在这种需要调整的情况下，虚表不直接指向一个虚函数指针，而是指向一个thunk（据说命名来源于Donald E.Knuth的Knuth倒过来），thunk中会生成调整this指针的代码，然后才是使用调整后的this调用虚函数。
    - 等效的伪代码看起来就像是这个样子，`doSomething_thunk`的地址被放到虚函数表项中：
    ```C++
    doSomething_thunk:
        this += offset;
        doSomething(this);
    ```
    - thunk技术允许虚表项中继续保存一个指针，而不需要额外保存一个偏移。于是对于那些不需要调整的虚函数（自然多态，大部分情况都是这样的），就没有任何额外负担了。
    - 所以即使调用同一个虚函数，经由派生类、第一个基类调用和经由第二个及以后的基类调用，在多重继承中的多个虚表中对应的thunk（自然多态则直接就是虚函数地址）都是不一样的，偏移是不一样的，但最终的效果都是使用相同的this调用同一个虚函数。
    - this指针调整是在访问虚表之后的，访问虚表则是根据调整前的基类子对象地址来的。
- 最后总结：
    - 多重继承中n个基类会产生n个虚表，第一个基类和派生类共用第一个虚指针与虚表：
        - 第一个基类只使用第一个虚表中前面的来自第一个基类的虚函数，而派生类会在其中加入继承自其他基类的和在派生类中新加入的虚函数。
        - 通过第一个基类指针引用或者派生类指针引用调用派生类引入的、重写的、或者继承自第一个基类的虚函数时直接使用this指针从虚表中找到并调用虚函数。
        - 通过派生类指针调用继承自第二个和后继基类的虚函数时（即未覆写的），需要经过thunk中的this指针调整将this调整到基类子对象地址，然后调用虚函数。
    - 第二个基类即后续的基类各拥有一个虚指针与虚表：
        - 当经由第二个基类指针引用来调用虚函数时，虚指针经由基类子对象来寻址（虚指针通常放对象开头），在调用派生类重写的虚函数时需要经过thunk中的this指针调整后，将this从基类子对象调整到派生类对象首地址，再调用虚函数。
    - 还有一种调整发生在派生类重写的虚函数返回基类虚函数返回值基础类型的派生类的指针引用的情况，如果这里的基类是多重继承的第二即后继基类，那么：
        - 此时如果用基类指针调用派生类虚函数，得到返回值后必须赋给基类指针或者引用，就需要进行一个指针转换，从派生类首地址转换为基类子对象地址。

一个生僻语法：
- 在C++的虚函数中，某些情况下派生类中重写的虚函数的返回值可以和基类不同。
    - 如果基类虚指针是基础类型，那么派生类的返回类型必须和父类严格一致，否则报错。
    - 如果基类虚函数返回某个基类指针或者引用，那么派生类虚函数的返回类型可以和基类返回类型相同，也可以是基类返回类型的派生类（不能是基类）的指针或引用。
- 这个规定让这种写法成为可能：
```C++
class Base1
{
public:
    virtual ~Base1() {}
    virtual Base1* clone()
    {
        return new Base1();
    }
};

class Base2
{
public:
    virtual ~Base2() {}
    virtual Base2* clone()
    {
        return new Base2();
    }
};

class Derived : public Base1, public Base2
{
public:
    virtual Derived* clone() override
    {
        return new Derived();
    }
};
```
- 派生类中同一个虚函数同时重写了两个基类的两个虚函数。也就是`Derived::clone()`函数的地址将同时位于派生类`Derived`的两个虚表中。
- 这个语法的核心逻辑就是里氏替换原则，也就是基类中返回基类的指针或者引用，因为派生类返回值是可以赋给基类指针和引用的。
- 但因为C++的模板是非协变（invariant）的，所以这里只能使用指针和引用这种语言语法层次的支持，而不能使用智能指针这种库定义或者自定义的东西。
- TODO：但在最新的C++20中，使用concept不知道能否做到自行实现的模板协变和逆变，待探究。

虚继承下的虚函数：
- 虚表中保存着虚基类相对对象首地址的偏移。
- 由于虚基类会被提取出来单独放在对象末尾，所以虚基类和其派生类天然就是非自然多态，自然会面临所有this指针调整的问题。再加上通过派生类地址获取虚基类子对象地址本身就要通过一层虚表查找的间接。
- 道理和上面是相同的，不再赘述。
- 就实践中而言，虚基类并非那么常见的角色，通常应该避免使用带有非静态成员的虚基类。


### 函数的效率

各种不同函数调用总体的性能从高到低大概是这个样子的：
- 内联函数。
- 全局函数、静态函数、非静态普通非虚函数。
- 虚函数。
- 多重继承中的虚函数。
- 虚继承中的虚函数。

原因：
- 内联函数直接嵌入，省去了函数调用参数传递成本。
- 虚函数有访问虚表的间接成本。
- 多重继承中的虚函数（通过thunk实现）相比普通虚函数有this指针调整的额外成本。
- 虚继承中访问虚基类子对象有额外间接成本。

### 成员函数指针

回顾数据成员指针：
- 数据成员指针通常本质上是一个整数值，这是一个不完全的值，它必须被绑定在一个类对象的地址上之后才能够被存取。

成员函数指针：
- 对成员函数取地址就会得到一个成员函数指针，得到的是内存中真正的该函数的地址。
- 但是这个值依然是不完全的，也需要被绑定到某对象（以参数this指出）之后才能够调用。
- 函数指针的类型是这个样子的：`RetType (ClassName::*)(args_type_list)`。
- 可以通过类对象使用`.*`或者指针使用`->*`来调用成员函数指针。
- 要将其作为一个普通函数对象来使用，可以使用`std::bind`绑定一个对象或者指针到第一个隐式参数上。
- 注意静态成员取地址得到的是普通函数指针，而非成员函数指针。
- 普通成员函数调用和全局、静态成员函数是一样的，没有额外消耗。

指向虚成员函数的指针：
- 虚成员函数同样支持取地址，用法和普通成员函数指针完全相同。
- 但是虚成员函数只有在运行时才能确定，对基类虚函数取地址，得到的是这个虚函数在虚表中的索引，然后通过派生类对象或者指针来调用时，应该调用派生类的对应虚函数。
- 所以虽然普通成员和虚成员函数可以有相同的函数签名，他们都可以被赋值给该类型的成员函数指针，但其中保存的值是存在差异的。
- 编译器实现时需要考虑这两种情况，并且必须要能够将他们区分出来。
- 在实现成员指针时，为了避免对普通函数的额外开销，同样可以使用thunk技术，普通函数直接指向成员函数，虚函数则指向一个thunk，其中保存虚函数索引并负责虚函数的运行时查找操作。
- 当然也可以在实现时使用一些手段区分普通成员和虚成员函数，可能会对普通成员函数有额外内存和运行时开销。
- 多重继承和虚继承下还会更加复杂。

成员指针的效率：
- 大体遵循上述函数调用效率的规则（从高到低）：普通成员函数、虚成员函数、多重继承中的虚函数、虚继承中的虚函数。

### 内联函数

内联函数：
- 使用inline关键字，或者在类声明中定义成员函数或者友元函数则会自动成为内联。
- 无论何种方式，inline都只是一个请求/建议，如果这个请求/建议被编译器接受，那么函数成为内联函数。
- 编译器会根据inline函数的复杂度来决定是否内联，如果编译器判断函数太过复杂，就会让其成为一个静态函数，在每个编译单元内都生成一个实例。但在链接时会清除掉多份重复的定义，仅保留一份，而不会像真的静态函数一样具有副作用。【思考：链接器如何决定是否要清除重复定义，inline属性被名称修饰函数名称上吗？】
- inline如果被编译器接受，那么在所有调用inline函数的位置，内联函数的二进制会被直接嵌入（内联扩展），免去函数参数传递和返回值的堆栈操作的开销。
- 如果inline被编译器接受了，函数定义在汇编和二进制中就没有了，必须在函数调用点才能寻找到内联函数的代码。

形式参数：
- 内联扩展时，每一个形参都会被对应的实参取代，一般来说，面对会带来副作用的形参，通常会引入临时变量以避免重复求值、修改参数等。
- 如果是常量表达式，可以在替换之前先求值。
- 如果既不是常量表达式，也不是带有副作用的表达式，那么可以直接替换。

局部变量：
- inline内部的局部变量通常会被直接扩展到调用的位置，当然每个变量都会拥有独一无二的重整后的名称。

总结：
- inline函数中的局部变量，加上有副作用的参数，可能会导致大量临时产生。
- inline函数对于封装提供了必要的支持，可以有效存取类中的非公有数据。
- 同时也是C中大量使用的宏函数/带参宏的替代品。
- inline通常放在头文件中，全局函数需要添加inline声明，成员函数或者友元函数可以直接定义在类内部以内联，外部则需要添加`inline`关键字。
- 比较简单的inline函数会直接内联扩展到函数调用处，比较复杂的则会在每个使用到的编译单元内生成代码。链接时则会消除重复代码（类似于对模板实例化处理，或者说模板实例化类似于内联函数的处理）。
- inline和模板一起提供了Header-only的库实现手段，免去链接的烦恼。（在二进制复用麻烦至极的C++上，Header-Only的开源库简直就是C++开发者的福音，如今的机器上这点编译时间消耗和二进制空间消耗已然无关紧要【当然在大型项目中可能依然需要考虑】，ABI复用困难那绕过ABI直接用源码就行了）。
- inline通常会提高程序性能，并增大最终生成的二进制的体积。属于空间换时间的典型手段。

最后，内联的虚函数：
- 虚函数可以内联，就算编译器接受了内联，依然会为函数生成二进制代码。
- 因为非多态调用时可以内联，但多态调用时则内联不了。