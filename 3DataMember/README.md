## 数据成员语义

先看一个例子：
```C++
class X {};
class Y : public virtual X {};
class Z : public virtual X {};
class A : public Y, public Z {};
```
- 本地环境gcc8.1.0中X，Y，Z，A的大小分别是1，8，8，16。
- X有1个字节是因为C++标准规定任何非附属对象都必须有非零大小，通常做法都是用一个字节来占位。
- Y和Z是因为保存了一个虚指针，虚表中虽然没有存放虚函数，但是存放了虚基类在对象中的偏移。
- A是多重继承，所以同时存储了来自Y和Z的虚指针，一共16字节。
- 而在YZ和A对象中，虚基类X的子对象的占用（在独立的X对象中有一个字节的占位符）则被优化掉了，其中X的子对象直接指向对象开头。这是现在的编译器中的普遍做法。

C++对象模型的演化：
- C++标准并不规定某些琐碎的细节，而是由实现自己决定，比如基类子对象的排列顺序，不同存取层级数据成员排列顺序。
- 当一种巧妙的实现被发掘出来，可能会迅速成为事实标准，但不会被规范为C++标准，久而久之也便成为了语言的一部分。
- 比如NRVO，比如上面所说的空虚基类优化，比如使用虚表这种手段来实现多态这件做法。
- 所以了解最普遍的做法，了解广泛使用的非标准的实现细节是有必要的。
- 注意区分什么是**C++标准**规定的，而什么是事实上的**C++实现标准**。编程需要依赖前者，但通常不应依赖后者。

C++对象的大小：
- 静态成员属于类，只有一份实例，放在全局数据段中，不在每一个对象中。
- 非静态数据成员将会影响最终的对象大小，除此之外还有两个原因：
    - 额外的用来支持多态、虚基类等特性的成员（通常来说这些东西加起来也就只有一个或多个虚指针而已）。
    - 字节对齐（alignment）导致的调整，会加入一些padding。

### 数据成员的绑定

类内嵌套类型声明的解析：
- 如果类内部声明了一个和一个全局类型同名的类型，那么在解析到这个类型声明之前，会将改名称解析为全局的类型。
- 所以为了避免这种错误，最好采用防御性编程策略，将类型中的所有类型声明添加到类的最开头。

成员的解析：
- 数据成员的解析则不同，编译时首先会先解析一遍所有成员声明，确定所有数据成员名称之后再回来解析函数。
- 所以数据成员是不需要这样做的。

### 数据成员的布局

数据成员布局：
- C++标准规定，在同一个访问区段中的不同变量，出现在后的一定拥有较高的地址。
- 但并不规定多个不同的访问区段之间怎么排布，但据我了解，并没有编译器会重排不同区段之间的顺序（属于道听途说式的了解，也许还待更透彻的了解）。
- 现实中多个区段可能会被连接到一起形成一个连续区块，访问区段的多少并不会带来任何负担。
- 除了用户定义的数据成员，编译器还会生成用以支持多态和虚基类的特殊成员，也即是虚指针（vptr）。普遍做法是将虚指针放在（子）对象最开头。
- 数据成员指针间可以比较大小，可以据此来判断谁前谁后。
- 关于继承、虚继承、多重继承等情况下虚指针与普通数据成员在特定环境下的成员布局可以参考[1Object](../1Object)中的讨论。

### 数据成员的存取

存取成本：
- 首先访问级别（private、protected、public）不会对存储一个成员的成本造成任何影响。不论是静态还是非静态数据成员。
- 通过对象存取成员`pt.x`，和通过指针存取成员`p->x`的成本差异：
    - 只有在取继承自虚基类的成员时才有成本差异，指针具有多态，多一层间接。

静态数据成员：
- 存储与类对象之外，静态生命周期。
- 每个静态数据成员只有一个实例，放在程序的数据段中，每次程序取用静态数据成员，都会被内部转化为对该唯一extern实例的直接操作。
- 所以通过对象或者指针使用`.`或者`->`对静态数据成员的访问是二进制等同的。
- 对静态数据成员取地址会得到一个其数据类型的指针，而不是成员指针。
- 多个类的同名静态成员会经过名称重整（name-mangling）后再二进制中得到不同的名字。
    - 名称重整会对每一个不同的名称推导出独一无二的名称。
    - 编译系统可以轻易将其推导回原来的名称。

非静态成员：
- 存放在每一个对象中。
- 只能通过显式（对象或者指针）或者隐式的类对象（this指针）才能存取它们。
- 要访问一个对象中的数据成员，就需要知道该成员相对对象首地址的偏移。比如访问`origin.y`，就等价于要`&origin + (&Point3d::y - 1)`这个地址。
    - 成员指针后续讨论，成员指针用于表示成员在对象中的偏移，并且其值通常为其实际偏移加1（不同实现中可能存在区别，但同一个道理），因为要和空成员指针（值为0）做区分。
- 每个成员的偏移总是在编译期就计算出来了，即使是基类成员（来自单一或者多重继承链条上的一个基类）。
- 有一个情况比较特殊，那就是虚继承，虚继承来的成员的访问必须经过虚基类子对象这一层间接层次。因为虚基类在对象中的偏移是不确定的，（通常来说）需要从虚表中读取。
    - 当然如果动态类型能够确定（通过对象访问），那么虚基类对象的偏移其实是编译期确定的，那么也不需要这一层间接。
    - 虚基类成员需要一层间接是指通过指针或者引用访问时，因为具有多态特性，对象的动态类型是不确定的，虚基类子对象放在对象的什么位置也就是不固定的，所以一定需要这一层间接，在运行时读取到虚基类子对象的偏移，才能确定继承自虚基类的成员的偏移。

### 继承与数据成员

关于普通单一继承、多重继承、虚继承、多重虚继承的内存布局依然见[1Object](../1Object)中的讨论。这里寥寥20页讨论的内容其实几十行代码就讨论清楚了。

C++标准：
- C++标准并不规定派生类成员和基类成员的排列顺序。理论上编译器自由安排，但大多数实现都是基类放在前，派生类成员在后。虚基类除外。
- 标准也并不规定多重继承的基类有特定排列顺序。理论上编译器自由安排，但实现中的普遍情况是按照基类声明顺序排列。

这里还是各种情况再讨论一下（依然就当前环境或讨论普遍做法）：
- 单一继承不含虚函数：继承并不会增加空间和存取时间的负担。没有虚函数所有没有虚指针，先基类成员再派生类成员。
- 单一继承不含虚函数，但是在派生类中引入虚函数：派生类对象会以虚指针开始，然后基类成员、派生类成员。但是基类没有虚指针，所以直接从基类成员开始。
- 单一继承含有虚函数：为基类和派生类对象加入虚指针成员（通常开头），在派生类中，这个虚指针被基类子对象和派生类对象共用。
- 多重继承：按照基类顺序，从地址低往高排列各个基类成员，如果基类有虚函数，那么基类子对象有虚指针，否则就没有。派生类和第一个基类共用虚指针（如果第一基类有虚指针的话，没有的话就是派生类独享的虚指针）。
    - 那么存取第二个或后继的基类的成员需要在运行时付出额外代价吗？并不需要，因为每个成员偏移都是在编译期就固定了。
- 虚继承：为了避免菱形继承中的基类数据重复的问题而引入了虚继承。通常做法是将虚基类直接提出来，将对象分割为两部分：一个不变区域（保存非虚基类、派生类成员），一个共享区域（保存虚基类成员）。
    - 不变区域中的基类子对象不管后续如何派生，其偏移都不会发生变化，其内部成员的偏移都可以在编译期固定下来，对其的访问不会带来额外运行时消耗。
    - 共享区域中的虚基类子对象，则可能随着每次派生操作发生变化，因其偏移无法固定，所以需要在运行时获取偏移，那么就需要将其保存在虚表中（具体保存在虚表什么位置由实现决定），也就需要间接存取，带来了额外运行时消耗。
    - 通常的布局策略都是先安排不变部分，也就是非虚基类（还需要将其中的虚基类子对象去掉），然后安排共享部分也就是虚基类的布局。
    - 在菱形虚继承中，虚基类的多个派生类中都会保存其虚基类的偏移在其虚表中，以便通过每个派生类对象或者子对象都能找到虚基类。第一个基类和派生类通常会共用虚表和虚指针，起始地址相同，对虚基类的偏移也相同。

多态的形式：
- 自然多态（natural polymorphism）：基类子对象和派生类对象共用同一起始地址，或共用同一虚指针，或都没有虚指针。派生类对象赋给基类指针时不需要编译器介入调整地址。
    - 在这种情况下，指针转换没有运行时代价。
- 非自然多态：基类子对象和派生类不共用同一起始地址，出现在基类没有虚指针而派生类有虚指针，或者多重继承的第一个以后的基类与派生类、虚继承中的虚基类和派生类。
    - 在这种情况下，指针转换的运行时代价会更高一些，需要加上一偏移，并且需要做空指针检测（在空指针上做偏移是不对的，会将其变为一个非空的指针）。
    - 引用则不需要做空值检测，因为引用不可能引用到空值上。
    - 如果是转换到虚基类对象，则还需要去虚表中取出虚基类子对象的偏移，加上判空操作，相教而言会多一层间接。

更多虚表的细节：
- 每个对象的动态类型的`type_info`对象被放到其中，以支持RTTI。
- 虚基类子对象（如果有的话）在该对象中的偏移被放在其中。
- 虚函数被按照顺序放置在其中，其中同一个虚函数在基类和派生类虚表中的索引是一致的。
    - 因为虚函数的间接调用被转换为了通过一个索引访问虚表元素，执行调用。
    - 所以就必须保证基类和不同的派生类中该索引处保存的是同一个虚函数。
    - 派生类中可以往虚表末尾增加这一层引入的新的虚函数，但前面的虚函数一定是与基类一致的。
    - 所以多重继承中一个类有多个虚表，继承的来自多个基类的索引必须要独立。在同一时刻只可能通过一个基类调用某一个虚函数，就是用的对应的基类子对象及虚表。
    - 然后多重继承时在该类中引入的新的虚函数会被加到哪个虚表中呢？（初步估计是开头的那一个，因为这个地址同时代表派生类对象地址（间接验证），暂未得到明确验证。）

一些其他的细节：
- 对于类设计者来说，选择一些函数做成inline，是设计类时的一个重要细节。
- 将本来可以设计在一个类中的多个成员拆分到多个具有派生层次的类中时，可能面临因为内存对齐而导致空间占用增加的情况。
- 不同编译器实现中可能将虚指针放在对象的不同位置。

运行时额外消耗总结：
- 成员存取：多态存取虚基类成员会需要一层间接，非多态存取或者存取普通基类成员都是编译期确定偏移，和普通成员存取同等消耗。
- 指针转换：自然多态无消耗，非自然多态需要判空并且加偏移，转换到虚基类还另外需要一层间接。
- 虚函数调用：多态调用虚函数需要访问虚表有一层间接，非多态调用不需要间接。

最佳实践：
- 虚函数会引入运行时消耗，这是实现多态的必要消耗，不可避免。
- 虚基类还会引入额外消耗，为了避免成员存取的间接消耗，通常一个最有效的运用虚基类的方式是使用抽象的没有任何成员的虚基类。

### 对象成员的效率

上面已经讨论过了，不赘述。

忠告：
- 如果关心程序的运行效率，应该进行实际测试，不要光凭推论、常识判断或者假设。
- 任何优化手段都应该以实际运行时间的降低体现出来，优化之前的第一步永远是找到性能瓶颈。

### 成员指针

- 前面提到过成员指针其实就是用其偏移来表示的，成员指针中存储的就是经过处理的成员偏移。
- 但是成员指针不可被直接转换为整型或者指针类型，这导致打印它的值成为困难。唯一可行的手段是使用`printf`打印。
- 前面提到通常编译器会在偏移上加上1作为其值以和空指针区分。
- 在本地环境GCC8.1.0中，不是这样做的，而是直接保存偏移，但是用-1来表示空成员指针。
- 可以通过对象或者指针使用`.*`或者`->*`运算符来访问一个类的成员指针。使用该运算符操作时将在运行时通过成员指针中的值确定成员偏移，引入了一层间接。



### TODO

- 从汇编层面准确分析一遍从内存布局、到虚表构成等所有的东西。